import os
import shutil
import tempfile
from collections import defaultdict
from typing import Iterable
import httpx
import trio
from anyio import open_file
from toolbox.mtg_vars import card_template, symbols_map, missing_cards


class DumperProgress(trio.abc.Instrument):
    pass


async def get_collected():
    url_template = "https://api.scryfall.com/cards/{expansion}/{number}"
    output = await open_file("poszukiwane.rst", "w")
    client = httpx.AsyncClient(timeout=15)
    async with output, client:
        await output.write("Poszukiwane karty\n=================\n")
        for title, links in missing_cards.items():
            await output.write(f"\n{title}\n{len(title) * '-'}\n\n")
            mapped = defaultdict(list)
            for link in links:
                expansion, number = link.split("/")[4:6]
                mapped[expansion].append(number)

            for expansion, numbers in mapped.items():
                for number in numbers:
                    card = await client.get(url_template.format(**locals()))
                    c = card.json()
                    await output.write(
                        f".. image:: {c['image_uris']['small']}\n"
                        f"   :target: {c['scryfall_uri']}\n"
                    )


async def queue_downloads(exp_list: Iterable):
    async with trio.open_nursery() as nursery:
        for exp in exp_list:
            nursery.start_soon(download_expansion, exp)


async def get_set_name(exp, client):
    result = await client.get(f"https://api.scryfall.com/sets/{exp.lower()}")
    if result.status_code != 200:
        raise httpx.ConnectError(f"Got error getting {exp} info: {result.status_code}")
    return result.json()["name"]


async def get_set_cards(exp, client):
    result = await client.get(
        f"https://api.scryfall.com/cards/search?order=set&q=e%3A{exp.lower()}&unique=prints",
    )
    if result.status_code != 200:
        raise httpx.ConnectError(
            f"Got error getting {exp} card list: {result.status_code}"
        )
    data = result.json()
    cards: list = data["data"]
    while data["has_more"]:
        result = await client.get(data["next_page"])
        data = result.json()
        cards.extend(data["data"])
    return cards


async def write_file_header(exp, name, file):
    await file.write(
        f".. {name} (autogenerated)\n"
        ".. include:: symbols.rst\n\n"
        f":mtgexp:`{exp}` {name}\n"
        f"{(len(name) + len(exp) + 12) * '='}\n\n"
    )


async def write_card_data(cards, file):
    cache = []
    for card in cards:
        if (card_name := card["name"]) not in cache:
            cache.append(card_name)
            await write_single_card(card, file)


async def write_single_card(card, file):
    faces = card.get("card_faces", [card])
    for face in faces:
        if "image_uris" in face:
            image_uri = face["image_uris"]["border_crop"]
        else:
            image_uri = card["image_uris"]["border_crop"]
        await file.write(
            card_template.format(
                card=face,
                card_uri=card["scryfall_uri"],
                image=image_uri,
                card_text=reformat_card_text(face.get("oracle_text", "")),
            )
        )


async def download_expansion(exp: str):
    fd, path = tempfile.mkstemp(text=True)
    output = await open_file(fd, "w")
    client = httpx.AsyncClient(timeout=15)
    async with output, client:
        # TODO: use local caching and refresh it at max every 24h
        # TODO: get only existing sets

        name = await get_set_name(exp, client)
        data = await get_set_cards(exp, client)
        await write_file_header(exp, name, output)
        await write_card_data(data, output)

    shutil.copy(path, f"{exp}.rst")
    os.remove(path)


def reformat_card_text(text, card_name=None):
    for t, s in symbols_map.items():
        text = text.replace(t, s)
    return text
